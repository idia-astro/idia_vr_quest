using System;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using Google.Protobuf;
using Grpc.Core;
using Services;
using UnityEngine;
using Debug = UnityEngine.Debug;

namespace VolumeData
{
    public class RemoteDataSource : IVolumeDataSource
    {
        public bool IsValid { get; private set; }
        public Texture3D ScaledDataTexture { get; private set; }
        public Vector3Int ScaledDataDownsamplingFactors { get; }
        public int ScaledDataLimit { get; set; }
        public Texture3D FloatDataTexture { get; private set; }

        public Vector3Int FloatDataDownsamplingFactors { get; }
        public int FloatDataLimit { get; set; }
        public Vector2 FloatDataBounds { get; private set; }
        public DataState DataState { get; private set; }
        public float Progress { get; private set; }
        public Vector3Int DataSourceDims { get; private set; }
        public Vector3Int CropMin { get; }
        public Vector3Int CropMax { get; }

        public Vector3Int ScaledDataDims => new Vector3Int(ScaledDataTexture?.width ?? 0, ScaledDataTexture?.height ?? 0, ScaledDataTexture?.depth ?? 0);
        public Vector3Int FloatDataDims => new Vector3Int(FloatDataTexture?.width ?? 0, FloatDataTexture?.height ?? 0, FloatDataTexture?.depth ?? 0);

        private int _fileId;
        private bool _requiresUpload;
        private int _channel;

        private Texture2D _floatSliceTexture;
        private Texture2D _scaledSliceTexture;

        public RemoteDataSource(string folder, string name)
        {
            IsValid = false;
            Progress = 0;
            DataState = DataState.Empty;
            _fileId = -1;
            _requiresUpload = false;
            _channel = 0;

            TestDecompression();

            _ = OpenFile(folder, name);
        }

        // Copied from https://stackoverflow.com/questions/321370/how-can-i-convert-a-hex-string-to-a-byte-array/321404
        private static byte[] StringToByteArray(string hexString) {
            byte[] data = new byte[hexString.Length / 2];
            for (int index = 0; index < data.Length; index++)
            {
                string byteValue = hexString.Substring(index * 2, 2);
                data[index] = byte.Parse(byteValue, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
            }

            return data; 
        }
        
        // Testing ZFP decompression with a hex string generated by compressing the data from "noise_10px_10px.fits" using zfp (p=12) 
        private void TestDecompression()
        {
            int precision = 12;
            int width = 10;
            int height = 10;
            int numPoints = width * height;

            IntPtr destPtr = Marshal.AllocHGlobal(sizeof(float) * numPoints);
            float[] destArray = new float[numPoints];
            for (int i = 0; i < numPoints; i++)
            {
                destArray[i] = 0;
            }
            Marshal.Copy(destArray, 0, destPtr, numPoints);

            byte[] srcArray = StringToByteArray("012d10008000dc2f5a379ef04bc4000a0e6801edc17348e766a944d4f8a6012d100004044440000214251004004214d002a130e0a2f3f03f36f48c30ab0f025a8080f720fd6a870c981795fbeb07b40001862084ca0c0a0cea8c4088025a8010d84c9184d08004218614d002012051906c2136301a882d4412025a8820b028040310044030040000");
            int compressedSize = srcArray.Length;
            IntPtr srcPtr = Marshal.AllocHGlobal(compressedSize);
            Marshal.Copy(srcArray, 0, srcPtr, compressedSize);
            Debug.Log($"Decompressing {compressedSize} bytes of ZFP data to a {width}x{height} float array using p={precision}");
            NativeFunctions.DecompressFloat2D(srcPtr, compressedSize, destPtr, width, height, precision);
            Marshal.Copy(destPtr, destArray, 0, numPoints);
            string resultString = "";
            for (int j = 0; j < height; j++)
            {
                for (int i = 0; i < width; i++)
                {
                    var val = destArray[j * width + i];
                    resultString += $"{val:F2} ";
                }

                resultString += "\n";
            }
            Debug.Log(resultString);
        }

        private async Task<bool> OpenFile(string folder, string name)
        {
            try
            {
                var backendService = BackendService.Instance;
                var imageInfo = await backendService.GetImageInfo(folder, name);
                if (imageInfo == null || imageInfo.Dimensions == null)
                {
                    Debug.LogError($"Error loading file information for {name}");
                    return false;
                }

                if (imageInfo.Dimensions?.Count < 3)
                {
                    Debug.LogError($"Image file {name} has fewer than 3 dimensions");
                    return false;
                }

                DataSourceDims = new Vector3Int(imageInfo.Dimensions[0], imageInfo.Dimensions[1], imageInfo.Dimensions[2]);
                InitTextures();

                _fileId = await backendService.OpenFile(folder, name);
                await StreamData(_fileId);
            }
            catch (RpcException ex)
            {
                Debug.LogError(ex.StatusCode + ex.Message);
                return false;
            }

            return true;
        }

        private async Task StreamData(int fileId)
        {
            try
            {
                Stopwatch sw = new Stopwatch();
                sw.Start();

                int totalSize = 0;
                int slice = 0;
                int pixelsPerSlice = DataSourceDims.x * DataSourceDims.y;

                var floatPixels = new float[pixelsPerSlice];
                var scaledPixels = new byte[pixelsPerSlice];
                var backendService = BackendService.Instance;

                using (var call = backendService.GetData(fileId))
                {
                    while (await call.ResponseStream.MoveNext())
                    {
                        var dataResponse = call.ResponseStream.Current;
                        FloatDataBounds = new Vector2(dataResponse.MinValue, dataResponse.MaxValue);

                        var dataSize = dataResponse.RawData.Length;
                        totalSize += dataSize;

                        var numProcessedSlices = UpdateTextures(dataResponse.RawData.ToByteArray(), floatPixels, scaledPixels, slice);
                        slice += numProcessedSlices;
                    }
                }

                sw.Stop();

                var timeMs = sw.ElapsedMilliseconds;
                var rate = (totalSize * 1e-3) / timeMs;
                Debug.Log($"Received {(totalSize / 1.0e6):F1} MB of data for fileId={_fileId} in {timeMs:F1} ms ({rate:F1} MB/s)");
            }
            catch (RpcException ex)
            {
                Debug.LogError(ex.StatusCode + ex.Message);
            }
        }

        private int UpdateTextures(byte[] rawData, float[] floatPixels, byte[] scaledPixels, int startingSlice)
        {
            int pixelsPerSlice = DataSourceDims.x * DataSourceDims.y;
            int bytesPerSlice = pixelsPerSlice * sizeof(float);
            int slicesPerMessage = rawData.Length / bytesPerSlice;
            for (int i = 0; i < slicesPerMessage; i++)
            {
                Buffer.BlockCopy(rawData, bytesPerSlice * i, floatPixels, 0, bytesPerSlice);

                var minValue = FloatDataBounds.x;
                var maxValue = FloatDataBounds.y;
                var range = maxValue - minValue;

                // Convert scaled array one-by-one
                for (int j = 0; j < pixelsPerSlice; j++)
                {
                    var val = floatPixels[j];
                    // handle numerical errors for min and max values
                    if (val == minValue)
                    {
                        val = 0;
                    }
                    else if (val == maxValue)
                    {
                        val = 255;
                    }
                    else
                    {
                        val = 255 * (val - minValue) / range;
                    }

                    scaledPixels[j] = (byte)Mathf.RoundToInt(val);
                }

                _scaledSliceTexture.SetPixelData(scaledPixels, 0);
                _floatSliceTexture.SetPixelData(floatPixels, 0);

                _scaledSliceTexture.Apply();
                _floatSliceTexture.Apply();
                Graphics.CopyTexture(_floatSliceTexture, 0, 0, 0, 0, DataSourceDims.x, DataSourceDims.y, FloatDataTexture, startingSlice + i, 0, 0, 0);
                Graphics.CopyTexture(_scaledSliceTexture, 0, 0, 0, 0, DataSourceDims.x, DataSourceDims.y, ScaledDataTexture, startingSlice + i, 0, 0, 0);
            }

            return slicesPerMessage;
        }

        private void InitTextures()
        {
            FloatDataTexture = new Texture3D(DataSourceDims.x, DataSourceDims.y, DataSourceDims.z, TextureFormat.RFloat, false)
            {
                wrapMode = TextureWrapMode.Clamp,
                filterMode = FilterMode.Point
            };

            ScaledDataTexture = new Texture3D(DataSourceDims.x, DataSourceDims.y, DataSourceDims.z, TextureFormat.R8, false)
            {
                wrapMode = TextureWrapMode.Clamp,
                filterMode = FilterMode.Point
            };

            _floatSliceTexture = new Texture2D(DataSourceDims.x, DataSourceDims.y, TextureFormat.RFloat, false)
            {
                wrapMode = TextureWrapMode.Clamp,
                filterMode = FilterMode.Point
            };

            _scaledSliceTexture = new Texture2D(DataSourceDims.x, DataSourceDims.y, TextureFormat.R8, false)
            {
                wrapMode = TextureWrapMode.Clamp,
                filterMode = FilterMode.Point
            };
        }

        private void UpdateTextures(float[] floatData)
        {
            var numPixels = floatData.Length;
            var minValue = FloatDataBounds.x;
            var maxValue = FloatDataBounds.y;
            var range = maxValue - minValue;

            var floatArray = FloatDataTexture.GetPixelData<float>(0);
            var scaledArray = ScaledDataTexture.GetPixelData<byte>(0);

            // Update all FP32 data in one go
            FloatDataTexture.SetPixelData(floatData, 0);

            // Convert scaled array one-by-one
            for (int i = 0; i < numPixels; i++)
            {
                var val = floatArray[i];
                // handle numerical errors for min and max values (suppress intellisense warnings)
                // ReSharper disable CompareOfFloatsByEqualityOperator
                if (val == minValue)
                {
                    val = 0;
                }
                else if (val == maxValue)
                {
                    val = 255;
                }
                else
                {
                    val = 255 * (val - minValue) / range;
                }
                // ReSharper restore CompareOfFloatsByEqualityOperator


                scaledArray[i] = (byte)Mathf.RoundToInt(val);
            }

            ScaledDataTexture.Apply();
            FloatDataTexture.Apply();
        }

        public void Update()
        {
        }

        public async Task<bool> RequestCrop(Vector3Int cropMin, Vector3Int cropMax)
        {
            await Task.Delay(10);
            return false;
        }

        public void Dispose()
        {
            if (_fileId >= 0)
            {
                Debug.Log($"Closing image with fileId={_fileId}");
                _ = BackendService.Instance.CloseFile(_fileId);
            }
        }
    }
}