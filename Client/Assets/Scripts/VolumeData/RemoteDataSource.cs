using System;
using System.Diagnostics;
using System.Globalization;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using Google.Protobuf;
using Grpc.Core;
using Services;
using UnityEngine;
using Debug = UnityEngine.Debug;

namespace VolumeData
{
    public class RemoteDataSource : IVolumeDataSource
    {
        public bool IsValid { get; private set; }
        public Texture3D ScaledDataTexture { get; private set; }
        public Vector3Int ScaledDataDownsamplingFactors { get; }
        public int ScaledDataLimit { get; set; }
        public Texture3D FloatDataTexture { get; private set; }

        public Vector3Int FloatDataDownsamplingFactors { get; }
        public int FloatDataLimit { get; set; }
        public Vector2 FloatDataBounds { get; private set; }
        public DataState DataState { get; private set; }
        public float Progress { get; private set; }
        public Vector3Int DataSourceDims { get; private set; }
        public Vector3Int CropMin { get; }
        public Vector3Int CropMax { get; }

        public Vector3Int ScaledDataDims => new Vector3Int(ScaledDataTexture?.width ?? 0, ScaledDataTexture?.height ?? 0, ScaledDataTexture?.depth ?? 0);
        public Vector3Int FloatDataDims => new Vector3Int(FloatDataTexture?.width ?? 0, FloatDataTexture?.height ?? 0, FloatDataTexture?.depth ?? 0);

        private int _fileId;
        private bool _requiresUpload;
        private int _channel;

        private Texture2D _floatSliceTexture;
        private Texture2D _scaledSliceTexture;

        public RemoteDataSource(string folder, string name)
        {
            IsValid = false;
            Progress = 0;
            DataState = DataState.Empty;
            _fileId = -1;
            _requiresUpload = false;
            _channel = 0;

            int inputVal = 5;
            int retVal = NativeFunctions.Test(inputVal);
            Debug.Log($"NativeFunctions.Test: {inputVal} => {retVal}");
            
            TestDecompression();

            _ = OpenFile(folder, name);
        }

        // Copied from https://stackoverflow.com/questions/321370/how-can-i-convert-a-hex-string-to-a-byte-array/321404
        private static byte[] StringToByteArray(string hexString) {
            byte[] data = new byte[hexString.Length / 2];
            for (int index = 0; index < data.Length; index++)
            {
                string byteValue = hexString.Substring(index * 2, 2);
                data[index] = byte.Parse(byteValue, NumberStyles.HexNumber, CultureInfo.InvariantCulture);
            }

            return data; 
        }
        
        // Testing ZFP decompression with a hex string generated by compressing the data from "noise_10px_10px.fits" using zfp (p=12) 
        private void TestDecompression()
        {
            int precision = 12;
            int width = 8;
            int height = 8;
            int depth = 8;
            int numPoints = width * height * depth;

            IntPtr destPtr = Marshal.AllocHGlobal(sizeof(float) * numPoints);
            float[] destArray = new float[numPoints];
            for (int i = 0; i < numPoints; i++)
            {
                destArray[i] = 0;
            }
            Marshal.Copy(destArray, 0, destPtr, numPoints);
            
            byte[] srcArray = StringToByteArray("f7b08edbed3351130300d0fbd951406f42d32100008a67dd1f001083006ab0002c171106f76ada10140cd7e04d4908c0a2ddc1a8303200d4240422e9918170f7f0542bac8183e4aad86861007a03531802b6ad1f048a67790e0010080006204a0800e02a2309002d471a0323c2594f18e595abc2c6789085a0be10331137bcab87277c7bf507b73cbad23f011ec37b0c0000a22d5dab0000a07898189ad0a4419d027b20706640d7f692c80190e734d9564c061d2fee9df9647e503dbcf565b68674c61f8db2c90628704a4478008adc659c026040f170ca200201e8833388dd0cf2831381228568f4b1328e21066f0ca0796dc8e5dc2d02dd00000000000000");
            int compressedSize = srcArray.Length;
            IntPtr srcPtr = Marshal.AllocHGlobal(compressedSize);
            Marshal.Copy(srcArray, 0, srcPtr, compressedSize);
            Debug.Log($"Decompressing {compressedSize} bytes of ZFP data to a {width}x{height} float array using p={precision}");
            int res = NativeFunctions.DecompressFloat3D(srcPtr, compressedSize, destPtr, width, height, depth, precision);
            Marshal.Copy(destPtr, destArray, 0, numPoints);
            string resultString = "";
            for (int k = 0; k < depth; k++)
            {
                for (int j = 0; j < height; j++)
                {
                    for (int i = 0; i < width; i++)
                    {
                        var val = destArray[k * (width * depth) + j * width + i];
                        resultString += $"{val:F2} ";
                    }

                    resultString += "\n";
                }
                resultString += "\n";
                resultString += "\n";

            }
            
            Debug.Log($"Compression status={res}");

            Debug.Log(resultString);
        }

        private async Task<bool> OpenFile(string folder, string name)
        {
            try
            {
                var backendService = BackendService.Instance;
                var imageInfo = await backendService.GetImageInfo(folder, name);
                if (imageInfo == null || imageInfo.Dimensions == null)
                {
                    Debug.LogError($"Error loading file information for {name}");
                    return false;
                }

                if (imageInfo.Dimensions?.Count < 3)
                {
                    Debug.LogError($"Image file {name} has fewer than 3 dimensions");
                    return false;
                }

                DataSourceDims = new Vector3Int(imageInfo.Dimensions[0], imageInfo.Dimensions[1], imageInfo.Dimensions[2]);
                InitTextures();

                _fileId = await backendService.OpenFile(folder, name);
                await StreamData(_fileId);
            }
            catch (RpcException ex)
            {
                Debug.LogError(ex.StatusCode + ex.Message);
                return false;
            }

            return true;
        }

        private async Task StreamData(int fileId)
        {
            try
            {
                Stopwatch sw = new Stopwatch();
                sw.Start();

                int totalSize = 0;
                int slice = 0;
                int pixelsPerSlice = DataSourceDims.x * DataSourceDims.y;

                var floatPixels = new float[pixelsPerSlice];
                var scaledPixels = new byte[pixelsPerSlice];
                var backendService = BackendService.Instance;

                using (var call = backendService.GetData(fileId))
                {
                    while (await call.ResponseStream.MoveNext())
                    {
                        var dataResponse = call.ResponseStream.Current;
                        FloatDataBounds = new Vector2(dataResponse.MinValue, dataResponse.MaxValue);

                        var dataSize = dataResponse.RawData.Length;
                        totalSize += dataSize;

                        var numProcessedSlices = UpdateTextures(dataResponse.RawData.ToByteArray(), floatPixels, scaledPixels, slice);
                        slice += numProcessedSlices;
                    }
                }

                sw.Stop();

                var timeMs = sw.ElapsedMilliseconds;
                var rate = (totalSize * 1e-3) / timeMs;
                Debug.Log($"Received {(totalSize / 1.0e6):F1} MB of data for fileId={_fileId} in {timeMs:F1} ms ({rate:F1} MB/s)");
            }
            catch (RpcException ex)
            {
                Debug.LogError(ex.StatusCode + ex.Message);
            }
        }

        private int UpdateTextures(byte[] rawData, float[] floatPixels, byte[] scaledPixels, int startingSlice)
        {
            int pixelsPerSlice = DataSourceDims.x * DataSourceDims.y;
            int bytesPerSlice = pixelsPerSlice * sizeof(float);
            int slicesPerMessage = rawData.Length / bytesPerSlice;
            for (int i = 0; i < slicesPerMessage; i++)
            {
                Buffer.BlockCopy(rawData, bytesPerSlice * i, floatPixels, 0, bytesPerSlice);

                var minValue = FloatDataBounds.x;
                var maxValue = FloatDataBounds.y;
                var range = maxValue - minValue;

                // Convert scaled array one-by-one
                for (int j = 0; j < pixelsPerSlice; j++)
                {
                    var val = floatPixels[j];
                    // handle numerical errors for min and max values
                    if (val == minValue)
                    {
                        val = 0;
                    }
                    else if (val == maxValue)
                    {
                        val = 255;
                    }
                    else
                    {
                        val = 255 * (val - minValue) / range;
                    }

                    scaledPixels[j] = (byte)Mathf.RoundToInt(val);
                }

                _scaledSliceTexture.SetPixelData(scaledPixels, 0);
                _floatSliceTexture.SetPixelData(floatPixels, 0);

                _scaledSliceTexture.Apply();
                _floatSliceTexture.Apply();
                Graphics.CopyTexture(_floatSliceTexture, 0, 0, 0, 0, DataSourceDims.x, DataSourceDims.y, FloatDataTexture, startingSlice + i, 0, 0, 0);
                Graphics.CopyTexture(_scaledSliceTexture, 0, 0, 0, 0, DataSourceDims.x, DataSourceDims.y, ScaledDataTexture, startingSlice + i, 0, 0, 0);
            }

            return slicesPerMessage;
        }

        private void InitTextures()
        {
            FloatDataTexture = new Texture3D(DataSourceDims.x, DataSourceDims.y, DataSourceDims.z, TextureFormat.RFloat, false)
            {
                wrapMode = TextureWrapMode.Clamp,
                filterMode = FilterMode.Point
            };

            ScaledDataTexture = new Texture3D(DataSourceDims.x, DataSourceDims.y, DataSourceDims.z, TextureFormat.R8, false)
            {
                wrapMode = TextureWrapMode.Clamp,
                filterMode = FilterMode.Point
            };

            _floatSliceTexture = new Texture2D(DataSourceDims.x, DataSourceDims.y, TextureFormat.RFloat, false)
            {
                wrapMode = TextureWrapMode.Clamp,
                filterMode = FilterMode.Point
            };

            _scaledSliceTexture = new Texture2D(DataSourceDims.x, DataSourceDims.y, TextureFormat.R8, false)
            {
                wrapMode = TextureWrapMode.Clamp,
                filterMode = FilterMode.Point
            };
        }

        private void UpdateTextures(float[] floatData)
        {
            var numPixels = floatData.Length;
            var minValue = FloatDataBounds.x;
            var maxValue = FloatDataBounds.y;
            var range = maxValue - minValue;

            var floatArray = FloatDataTexture.GetPixelData<float>(0);
            var scaledArray = ScaledDataTexture.GetPixelData<byte>(0);

            // Update all FP32 data in one go
            FloatDataTexture.SetPixelData(floatData, 0);

            // Convert scaled array one-by-one
            for (int i = 0; i < numPixels; i++)
            {
                var val = floatArray[i];
                // handle numerical errors for min and max values (suppress intellisense warnings)
                // ReSharper disable CompareOfFloatsByEqualityOperator
                if (val == minValue)
                {
                    val = 0;
                }
                else if (val == maxValue)
                {
                    val = 255;
                }
                else
                {
                    val = 255 * (val - minValue) / range;
                }
                // ReSharper restore CompareOfFloatsByEqualityOperator


                scaledArray[i] = (byte)Mathf.RoundToInt(val);
            }

            ScaledDataTexture.Apply();
            FloatDataTexture.Apply();
        }

        public void Update()
        {
        }

        public async Task<bool> RequestCrop(Vector3Int cropMin, Vector3Int cropMax)
        {
            await Task.Delay(10);
            return false;
        }

        public void Dispose()
        {
            if (_fileId >= 0)
            {
                Debug.Log($"Closing image with fileId={_fileId}");
                _ = BackendService.Instance.CloseFile(_fileId);
            }
        }
    }
}